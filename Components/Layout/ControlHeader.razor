@inject IDialogService DialogService

@rendermode InteractiveServer

@using BlazorTaskManager.Models

<MudPopoverProvider />
<MudDialogProvider />
<MudSnackbarProvider />

<div class="header">
    <!-- Dynamic tabs -->
    <MudDynamicTabs 
    @ref="@DynamicTabs"
    @bind-ActivePanelIndex="@UserIndex"
    AddTab="@AddTabCallback"
    CloseTab="@CloseTabCallback"
    AddIconToolTip="Add new"
    CloseIconToolTip="Close tab"
    Elevation="0">

        @foreach (var tab in UserTabs)
        {
            <MudTabPanel ID="@tab.Id" Text="@tab.Label" ShowCloseIcon="@tab.ShowCloseIcon"></MudTabPanel>
        }

    </MudDynamicTabs>

    <!-- Dark/light toggle & screen select -->
    <div class="header-options">
        <MudSwitch 
        @bind-Value="DarkMode"
        Color="Color.Primary"
        UncheckedColor="Color.Primary"
        Style="margin: auto;"
        ThumbIcon="@(darkMode ? Icons.Material.Filled.DarkMode : Icons.Material.Filled.LightMode)"
        ThumbIconColor="Color.Info"
        Size="Size.Large" />

        <MudToggleGroup T="string"
        @bind-Value="Screen"
        Outlined="false"
        Delimiters="false"
        Size="Size.Medium"
        Rounded="false"
        CheckMark="false"
        FixedContent="false"
        Disabled="false"
        Style="width: auto;">

            <MudToggleItem Value="@("Dashboard")">
                <MudIcon Icon="@Icons.Material.Filled.Home" />
            </MudToggleItem>

            <MudToggleItem Value="@("Task list")">
                <MudIcon Icon="@Icons.Material.Filled.FormatListBulleted" />
            </MudToggleItem>

            <MudToggleItem Value="@("Kanban")">
                <MudIcon Icon="@Icons.Material.Filled.ViewKanban" />
            </MudToggleItem>

        </MudToggleGroup>
    </div>


    <!-- Message popups -->
    <MudMessageBox @ref="confirmDeleteMessage" Title="Warning" CancelText="Cancel">
        <MessageContent>
            Deleting this tab will <b>remove all its tasks.</b> this <b>cannot</b> be undone.
        </MessageContent>
        <YesButton>
            <MudButton Variant="Variant.Filled" Color="Color.Error" StartIcon="@Icons.Material.Filled.DeleteForever">Delete</MudButton>
        </YesButton>
    </MudMessageBox>

    <MudMessageBox @ref="createTabMessage" Title="New tab" CancelText="Cancel">
        <MessageContent>
            <p>Please name your new tab</p>
            <br />
            <MudInputString Placeholder="Name" @bind-Value="newTabName" />
            <br />
        </MessageContent>
        <YesButton>
            <MudButton Variant="Variant.Filled" Color="Color.Success" StartIcon="@Icons.Material.Filled.Check">Create</MudButton>
        </YesButton>
    </MudMessageBox>

</div>

@code {
    protected override void OnInitialized()
    {
        base.OnInitialized();
        RestoreUserTabs();

        OnScreenChange.InvokeAsync(screen);
        OnDarkModeToggle.InvokeAsync(darkMode);
    }

    #region Properties
    [Parameter]
    public EventCallback<string> OnScreenChange { get; set; }

    [Parameter]
    public EventCallback<bool> OnDarkModeToggle { get; set; }

    [Parameter]
    public EventCallback<Guid> OnActiveTabChange { get; set; }

    private string screen = "Dashboard";

    public string Screen
    {
        get { return screen; }
        set
        {
            screen = value;
            OnScreenChange.InvokeAsync(screen);
        }
    }

    private bool darkMode = true;

    public bool DarkMode
    {
        get { return darkMode; }
        set
        {
            darkMode = value;
            OnDarkModeToggle.InvokeAsync(darkMode);
        }
    }

    private Guid currentTabId;

    public Guid CurrentTabId
    {
        get { return currentTabId; }
        set
        {
            currentTabId = value;
            OnActiveTabChange.InvokeAsync(currentTabId);
        }
    }
    #endregion

    #region Dynamic Tabs
    // This code is taken from https://mudblazor.com/components/tabs#dynamic-tabs and modified where needed
    public MudDynamicTabs DynamicTabs;
    public List<TabView> UserTabs = new();

    private int userIndex;

    public int UserIndex
    {
        get { return userIndex; }
        set
        {
            userIndex = value;
            try
            {
                CurrentTabId = UserTabs[value].Id;
            }
            catch{
                CurrentTabId = UserTabs[0].Id;
            }
    }
    }


    bool _stateHasChanged;
    bool _showCloseIcon = false;
    string _closeToggableTab = "Tab B";

    void RestoreUserTabs()
    {
        UserTabs.Clear();
        UserTabs.Add(new TabView { Id = Guid.NewGuid(), Label = "Untitled", TaskList = new List<TaskItem>(), ShowCloseIcon = false });
        UserIndex = 0;
        _stateHasChanged = true;
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (_stateHasChanged)
        {
            _stateHasChanged = false;

            // Set ShowCloseIcon to false if there is only one tab
            UserTabs[0].ShowCloseIcon = UserTabs.Count <= 1 ? false : true;

            StateHasChanged();
        }
    }

    private void ToggleShowCloseIcon(bool show)
    {
        var tab = UserTabs?.SingleOrDefault(t => t.Label.Equals(_closeToggableTab));
        if (tab is not null) tab.ShowCloseIcon = show;
        _showCloseIcon = show;
    }

    public async void AddTab(Guid id)
    {
        bool? confirmCreate = await NameTabAsync();

        if (confirmCreate == true)
        {
            UserTabs.Add(new TabView { Id = id, Label = newTabName, TaskList = new List<TaskItem>() });
            UserIndex = UserTabs.Count - 1; // Automatically switch to the new tab.
            _stateHasChanged = true;
        }

        newTabName = "";
    }

    public async void RemoveTab(Guid id)
    {
        bool? confirmRemove = await ConfirmDeleteAsync();

        if (confirmRemove == true)
        {

            var tabView = UserTabs.SingleOrDefault((t) => Equals(t.Id, id));
            var currentTabView = UserTabs[UserIndex];
            if (tabView is not null)
            {
                // Would encounter exceptions when removing tabs due to main content's UserIndex being out of range
                // Added logic here to ensure UserIndex updates properly to avoid the exception
                int removingIndex = UserTabs.IndexOf(tabView);

                bool currentTabIsRemoved = false;
                if (currentTabView == tabView) { currentTabIsRemoved = true; }

                UserTabs.Remove(tabView);

                UserIndex = currentTabIsRemoved ? --UserIndex : UserTabs.IndexOf(currentTabView);
                UserIndex = UserIndex < 0 ? 0 : UserIndex;

                _stateHasChanged = true;
            }
        }
    }

    void AddTabCallback() => AddTab(Guid.NewGuid());
    void CloseTabCallback(MudTabPanel panel) => RemoveTab((Guid)panel.ID);
    #endregion

    #region Message popups
    // This code is taken from https://mudblazor.com/components/messagebox#api and modified where needed
    private MudMessageBox confirmDeleteMessage;
    private MudMessageBox createTabMessage;

    public string newTabName;

    private async Task<bool?> ConfirmDeleteAsync()
    {
        bool? result = await confirmDeleteMessage.ShowAsync();
        result = result == null ? false : true;
        StateHasChanged();

        return result;
    }

    private async Task<bool?> NameTabAsync()
    {
        bool? result = await createTabMessage.ShowAsync();
        result = result == null ? false : true;
        StateHasChanged();

        return result;
    }
    #endregion

}
